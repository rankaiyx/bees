bees Configuration
==================

必须提供的唯一配置参数是哈希表大小。其他参数是可选的或硬编码的，默认设置在大多数情况下都是合理的。

Hash Table Sizing
-----------------

哈希表条目为每个数据块16字节。哈希表存储最近读取的唯一哈希。一旦哈希表已满，表中的每个新条目都会逐出一个旧条目。

以下是一些用于估计适当哈希表大小的数字：

    unique data size |  hash table size |average dedupe extent size
        1TB          |      4GB         |        4K
        1TB          |      1GB         |       16K
        1TB          |    256MB         |       64K
        1TB          |    128MB         |      128K <- recommended
        1TB          |     16MB         |     1024K
       64TB          |      1GB         |     1024K

备注：

 * 如果哈希表太大，则不会获得额外的重复数据删除效率，额外的空间只会浪费RAM。额外的空间还会阻止旧数据被逐出，从而降低蜜蜂的速度，因此蜜蜂浪费时间寻找文件系统中不再存在的匹配数据。

 * 如果哈希表太小，则蜜蜂会从匹配的块中进行推断，以找到文件系统中已从哈希表中逐出的匹配的相邻块。换句话说，蜜蜂只需要在两个扩展区之间找到一个共同的块，就能够对整个扩展区执行重复数据删除。与其他重复数据消除工具相比，这可显著提高每散列表字节的重复数据消除命中率。

 * 在计算压缩数据块中的唯一数据以估计最佳哈希表大小时，请计算数据的未压缩大小。

 * 另一种接近哈希表大小的方法是，简单地确定可以节省多少RAM而不会带来太多不适，给蜜蜂提供该数量的RAM，并接受由此产生的任何重复数据消除命中率。蜜蜂将尽其所能地利用它得到的RAM做最好的工作。

影响最佳哈希表大小的因素
-----------------------------------------

如果不对文件系统数据及其结构进行深入检查，就很难预测数据布局和访问模式对重复数据消除效率的净影响--这项任务与执行重复数据删除一样昂贵。

与未压缩的文件系统相比，文件系统上的压缩减少了平均盘区长度。Btrfs上的最大压缩盘区长度为128KB，而最大未压缩盘区长度为128MB。较长的盘区减小最佳哈希表大小，而较短的盘区增加最佳哈希表大小，因为在每个盘区中存在(即未被逐出)哈希表条目的概率与盘区长度成正比。

根据经验，压缩文件系统的最佳哈希表大小是未压缩文件系统上相同数据的最佳哈希表大小的2-4倍。当哈希表小于128MB/TB时，重复数据消除效率会大幅下降，因为平均重复数据消除扩展区大小大于可能的最大压缩扩展区大小(128KB)。

短写入还缩短了平均区段长度并增加了最佳哈希表大小。如果数据库使用4K页面写入随机写入文件，则所有这些区段的长度都将为4K，因此必须增加哈希表大小以保留每个区段(否则用户必须接受较低的重复数据消除命中率)。

对具有多次短写入的文件进行碎片整理会增加盘区长度，从而减小最佳哈希表大小。

重复写入之间的时间也会影响最佳哈希表大小。BEES在第一次遍历时按逻辑顺序读取数据块，然后在写入新数据块几秒钟或几分钟后以递增方式读取新数据块。如果匹配读取之间的数据量较小，即从哈希表中收回的数据块较少，则BEES会找到更多匹配数据块。如果对文件系统的大多数相同写入几乎同时发生，则最佳哈希表大小较小。如果大多数相同的写入发生在较长的时间间隔内，则最佳散列表大小必须更大，以避免在找到匹配之前从表中逐出散列。

例如，构建服务器通常一遍又一遍地写出非常相似的源代码文件，因此它需要比备份服务器更小的哈希表，而备份服务器在每次向服务器添加新的客户端计算机的数据时都必须引用文件系统上最旧的数据。

多个子卷的扫描模式
-----------------------------------

--scan-mode选项会影响BEES如何在子卷之间分配资源。当有快照时，这一点尤其重要，因为需要根据文件系统上快照的使用方式进行权衡。

请注意，如果文件系统只有一个子卷(即根目录，子卷ID为5)，则--scan-mode选项不起作用，因为只有一个子卷要扫描。

默认模式为模式0，即“锁步”。在此模式下，在移动到每个子卷中的下一个索引节点之前，将同时扫描每个子卷的每个索引节点。这最大限度地提高了同时扫描对文件快照的所有引用的可能性，从而利用了Linux内核中的VFS缓存。如果经常创建快照，则BEE将不会取得很好的进展，因为每次创建新快照时，它都会不断从头重新启动文件系统扫描。

扫描模式1，“独立”，简单地并行地独立扫描每个子卷。每个子卷的扫描仪与所有其他子卷扫描仪平分时间。无论何时出现新的子卷，都会创建一个新的扫描仪，新的子卷扫描仪不会影响任何现有子卷扫描仪的行为。

扫描模式2(“顺序”)在进入下一个子卷之前完全处理每个子卷。在文件系统上首次使用BEE时，这是一个很好的模式，因为该文件系统已经有许多现有快照，并且新快照的创建率很高。短寿命的快照(例如，用于btrfs发送的快照)被有效地忽略，并且BEES将其努力指向更有可能是快照的原始子卷的较老的子卷。通过首先对原始子卷执行重复数据消除，Bees可确保将来的快照已执行重复数据消除，不需要再次执行重复数据消除。

如果您是第一次在具有许多现有快照的文件系统上使用BEE，那么您应该阅读有关快照问题的内容。

线程和负载管理
---------------------------

默认情况下，Bees为检测到的每个CPU创建一个工作线程。然后，这些线程执行扫描和重复数据删除操作。可以使用--thread-count和--thread-factor选项设置工作线程的数量。

如果需要，蜜蜂可以根据系统负载自动增加或减少工作线程的数量。这样可以在系统上其他CPU和IO密集型负载处于活动状态时暂停BEE，并在其他负载处于非活动状态时恢复BEE，从而减少对系统其余部分的影响。这是使用--loadavg-target和--thread-min选项配置的。

日志详细程度
-------------

使用--Verbose选项可以减少bees的闲聊。
